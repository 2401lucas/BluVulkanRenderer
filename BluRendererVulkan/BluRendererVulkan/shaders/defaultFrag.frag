#version 450#extension GL_EXT_nonuniform_qualifier : enablelayout(push_constant) uniform PushConstantData {    vec4 index; //X is Texture ID, Z is Material Index, W is texture type (Basic, Diff/Spec, PBR)} pushConsts;layout(set = 1, binding = 0) uniform sampler2D[] textureSamplers;struct LightInfo {	vec4 position;	//XYZ for position, W for light type	vec4 rotation;	//XYZ  for rotation	vec4 colour;	//XYZ for RGB, W for Intensity	vec4 distInfo;	// X for Const, Y for Linear, Z for Quad, W for Spot Light cutoff angle};layout(set = 0, binding = 1) uniform GPUSceneData {	vec4 cameraPosition;	//XYZ for position, W for number of Lights	vec4 ambientColor;		//XYZ for RGB, W for Intensity	LightInfo[16] lights;} sceneData;layout(location = 0) in vec3 fragColour;layout(location = 1) in vec3 fragNormal;layout(location = 2) in vec3 fragPosition;layout(location = 3) in vec2 fragTexCoord;layout(location = 0) out vec4 outColour;//TODO: Convert to doing light calculations in view spacevec3 calcDirectionalLight(vec3 normal, vec3 viewDir, vec3 lightDir) {	vec3 reflectDir = reflect(-lightDir, normal);	float diff = max(dot(normal, lightDir), 0.0);	float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);	vec3 ambient  = 0 * vec3(texture(textureSamplers[int(pushConsts.index.y + 1)], fragTexCoord));	vec3 diffuse  = diff * vec3(texture(textureSamplers[int(pushConsts.index.y + 1)], fragTexCoord)); 	vec3 specular = spec * vec3(texture(textureSamplers[int(pushConsts.index.y + 2)], fragTexCoord)); 		return (ambient + diffuse + specular);}vec3 calcPointLight(vec3 normal, vec3 viewDir, vec3 lightPos, vec3 distInfo) {	vec3 lightDir = normalize(lightPos - fragPosition);	vec3 reflectDir = reflect(-lightDir, normal);	float diff = max(dot(normal, lightDir), 0.0);	float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);	vec3 ambient  = 0 * vec3(texture(textureSamplers[int(pushConsts.index.y + 2)], fragTexCoord));	vec3 diffuse  = diff * vec3(texture(textureSamplers[int(pushConsts.index.y + 2)], fragTexCoord)); 	vec3 specular = spec * vec3(texture(textureSamplers[int(pushConsts.index.y + 1)], fragTexCoord)); 	// attenuation    float distance    = length(lightPos - fragPosition);    float attenuation = 1.0 / (distInfo.x + distInfo.y * distance + distInfo.z * (distance * distance)); 	return (ambient + diffuse + specular) * attenuation;}vec3 calcSpotLight(vec3 normal, vec3 viewDir, vec3 lightPos, vec3 lightRot, vec3 distInfo, float innerCutoff, float outerCutoff) {	vec3 lightDir = normalize(lightPos - fragPosition);		float theta = dot(lightDir, normalize(-lightRot));	float epsilon = innerCutoff - outerCutoff;	float intensity = clamp((theta - outerCutoff) / epsilon, 0.0, 1.0);    	if(theta > innerCutoff) {		return vec3(0,0,0); }	vec3 reflectDir = reflect(-lightRot, normal);	float diff = max(dot(normal, lightRot), 0.0);	float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);	vec3 diffuse  = diff * vec3(texture(textureSamplers[int(pushConsts.index.y + 1)], fragTexCoord)) * intensity; 	vec3 specular = spec * vec3(texture(textureSamplers[int(pushConsts.index.y + 2)], fragTexCoord)) * intensity; 	// attenuation    float distance    = length(lightPos - fragPosition);    float attenuation = 1.0 / (distInfo.x + distInfo.y * distance + distInfo.z * (distance * distance)); 	return (diffuse + specular) * attenuation;}void main() {	vec3 norm = normalize(fragNormal);	vec3 result = sceneData.ambientColor.xyz * sceneData.ambientColor.w * vec3(texture(textureSamplers[int(pushConsts.index.y)], fragTexCoord));	vec3 viewDir = normalize(sceneData.cameraPosition.xyz - fragPosition);		for (int i = 0; i < sceneData.cameraPosition.w; i++)	{		if(sceneData.lights[i].position.w == 0) {		break;		}		//Directional Lighting		else if(sceneData.lights[i].position.w == 1) {			result += calcDirectionalLight(norm, viewDir, sceneData.lights[i].rotation.xyz) * sceneData.lights[i].colour.xyz * sceneData.lights[i].colour.w;		}		//Point Lighting		else if(sceneData.lights[i].position.w == 2) {			result += calcPointLight(norm, viewDir, sceneData.lights[i].position.xyz, sceneData.lights[i].distInfo.xyz) * sceneData.lights[i].colour.xyz * sceneData.lights[i].colour.w;		}		//Spot Lighting		else if(sceneData.lights[i].position.w == 3) {			result += calcSpotLight(norm, viewDir, sceneData.lights[i].position.xyz, sceneData.lights[i].rotation.xyz, sceneData.lights[i].distInfo.xyz, sceneData.lights[i].rotation.w, sceneData.lights[i].distInfo.w) * sceneData.lights[i].colour.xyz * sceneData.lights[i].colour.w;		}	}	outColour = texture(textureSamplers[int(pushConsts.index.x)], fragTexCoord.xy) * vec4(result, 1.0);}